# JavaScript Best Practices
---

#### 1. Используйте === вместо ==.
Во избежание сюрпризов следует использовать только "строгое сравнение", так как оператор == осуществляет приведение типов перед сравнением, что может вызвать не совсем те результаты, которые мы ожидаем.

``` js
0 == "";    // true  
0 === "";   // false
```

#### 2. Избегайте глобальных переменных.
Сведите к минимуму количество глобальных переменных. Тем самым вы значительно снижаете шанс их перезаписи или нежелательного взаимодействия с другими скриптами.

``` js
var name = 'Yuriy';  
var lastName = 'Kurbakov';  
  
function doSomething() {...}  
  
console.log(name); // 'Yuriy' или window.name  
```

#### 3. Комментируйте ваш код.
Это кажется излишним в начале, но может случится так, что когда вы вернетесь к проекту через несколько месяцев и обнаружите, что не помните, что этот кусок кода делает. Или что будет, если ваш коллега будет смотреть ваш код в процессе код-ревью? Поэтому всегда комментируйте важные части кода.

``` js
// Проходим циклом по массиву и выводим каждый его элемент   
for(var i = 0, len = array.length; i < len; i++) {  
   console.log(array[i]);  
}
```

#### 4. Всегда используйте точку с запятой.
Технически, большинство браузеров позволят вам не использовать их. Но использование подобной практики потенциально может привести к гораздо более большим и, что еще хуже, плохо отлавливаемым проблемам.

``` js
var someItem = 'some string';  
function doSomething() {  
  return 'something';  
}
```

#### 5. Используйте стрелочные функции всегда, когда нужно сохранить лексическое значение this.
Часто при использовании вложенных функций бывает нужно отделить контекст this от его лексической области видимости. Распространённым решением этой проблемы является хранение контекста this в переменной или привязать контекст. Используя стрелочные функции, лексическое значение this не скрыто

```js 
function Person(name) {
    this.name = name;
}

Person.prototype.prefixName = function (arr) {
    return arr.map(character => this.name + character);
};
```

#### 6. Используйте стрелочные функции вместо функциональных выражений, когда это уместно
Стрелочные функции более понятны, когда используются для написания функций, просто возвращающих значение. К тому же с ними код выглядит чище.

``` js
var squares = arr.map(function (x) { return x * x });
const squares = arr.map(x => x * x);
```

#### 7. Используйте шаблонные литералы.
Используя шаблонные литералы, мы можем спокойно использовать в строках специальные символы. Шаблонные литералы также поддерживают интерполяцию, что делает задачу конкатенации строк и значений гораздо проще.

``` js
var text = "This string contains \"double quotes\" which are escaped.";
let text = `This string contains "double quotes" which don't need to be escaped anymore.`;
```

``` js
console.log('My cat is named ' + name + ' and is ' + age + ' years old.');
console.log(`My cat is named ${name} and is ${age} years old.`);
```

#### 8. Используйте деструктуризацию объектов и массивов.
Деструктуризация позволяет нам извлекать значения из массивов и объектов (даже вложенных) и помещать их в переменные более удобным способом.

``` js
var arr = [1, 2, 3, 4];
var a = arr[0];
var b = arr[1];
var c = arr[2];
var d = arr[3];

let [a, b, c, d] = [1, 2, 3, 4];
console.log(a); // 1
console.log(b); // 2
```

``` js
var luke = { occupation: 'jedi', father: 'anakin' };
var occupation = luke.occupation; // 'jedi'
var father = luke.father; // 'anakin'

let luke = { occupation: 'jedi', father: 'anakin' };
let {occupation, father} = luke;
console.log(occupation); // 'jedi'
console.log(father); // 'anakin'
```

#### 9. Используйте параметры по умолчанию.
В ES5 было несколько способов обработки функций со значениями по умолчанию, неопределёнными аргументами и именованными параметрами. В ES6 всё это реализуется, причём с понятным синтаксисом.

``` js
function addTwoNumbers(x, y) {
    x = x || 0;
    y = y || 0;
    return x + y;
}

function addTwoNumbers(x=0, y=0) {
    return x + y;
}
```

#### 10. Для работы с прототипами предпочтительнее использовать классы. 
До ES6 классы нужно было создавать, добавляя к функции-конструктору свойства, расширяя прототип. ES6 предоставляет весьма удобный синтаксический сахар. Классы можно создавать достаточно просто. Хотя такой синтаксис и скрывает реализацию, новичкам в нём будет проще разобраться, да и написанный код будет чище.

``` js
function Person(name, age, gender) {
    this.name   = name;
    this.age    = age;
    this.gender = gender;
}

Person.prototype.incrementAge = function () {
    return this.age += 1;
};
```

```js
class Person {
    constructor(name, age, gender) {
        this.name   = name;
        this.age    = age;
        this.gender = gender;
    }

    incrementAge() {
      this.age += 1;
    }
}
```
